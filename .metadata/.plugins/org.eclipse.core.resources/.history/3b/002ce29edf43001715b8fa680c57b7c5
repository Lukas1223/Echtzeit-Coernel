
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <time.h>

#include "diagram.h"

const color red = { 255, 0, 0 };
const color blue = { 0, 0, 255 };
const color cyan = { 0, 255, 255 };
const color green = { 0, 255, 0 };
const color yellow = { 255, 255, 0 };
const color purple = { 124, 0, 83 };

/* struct d_param
 * @brief structure that holds relevant data for diagram scaling
 */
struct d_param {
	int xmin;		//minimum x value
	int xmax;		//maximum x value
	int ymin;		//minimum y value
	int ymax;		//maximum y value
	int xabs;		//absolute count of x values
	int yabs;		//absolute count of x values
	int xpixstep;	//stepwidth of x value in pixel
	int ypixstep;	//stepwidth of y value in pixel
	int xpixzero;	//zero of x value in pixel
	int ypixzero;	//zero of y value in pixel
} par;

double p[2][10] = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0 } };

/* function InitScreen
 * @brief init titled screen with 640x480 video mode and alpha blending
 * 
 * @param	*screen		pointer to surface handler
 * @param	title		screen title
 * @return	void
 */
int InitScreen(SDL_Surface **screen, const char* const title) {
	const SDL_VideoInfo *info;
	Uint8 video_bpp;
	Uint32 videoflags;

	//Initialize SDL 
	if (SDL_Init(SDL_INIT_VIDEO) < 0) {
		fprintf(stderr, "Couldn't initialize SDL: %s\n", SDL_GetError());
		exit(1);
	}
	atexit(SDL_Quit);

	//Alpha blending doesn't work well at 8-bit color
	info = SDL_GetVideoInfo();
	if (info->vfmt->BitsPerPixel > 8) {
		video_bpp = info->vfmt->BitsPerPixel;
	} else {
		video_bpp = 16;
	}
	videoflags = SDL_SWSURFACE | SDL_SRCALPHA | SDL_RESIZABLE;

	//Set 640x480 video mode
	if ((*screen = SDL_SetVideoMode(WIDTH, HEIGHT, video_bpp, videoflags))
			== NULL) {
		fprintf(stderr, "Couldn't set %ix%i video mode: %s\n", WIDTH, HEIGHT,
				SDL_GetError());
		exit(2);
	}

	//Use alpha blending
	SDL_SetAlpha(*screen, SDL_SRCALPHA, 0);

	//Set title for window
	SDL_WM_SetCaption(title, title);
	return 0;
}

/* function ClearScreen
 * @brief clear screen
 * 
 * @param	*screen			pointer to surface handler
 * @return	void
 */
void ClearScreen(SDL_Surface **screen) {
	boxRGBA(*screen, 0, 0, WIDTH - 1, HEIGHT - 1, 0, 0, 0, 255);
}

/* function DrawDiagram
 * @brief draw an user-scaled diagram
 * 
 * @param	*screen			pointer to surface handler
 * @param	xtitle,ytitle	axis titles
 * @param	xmin, xmax		x-size
 * @param	ymin, ymax		y-size
 * @param	xscale,yscale	axis scaling
 * @return	0 on success\n -1 on error  
 * 
 * @TODO	just integer scaling
 */
int DrawDiagram(SDL_Surface **screen, const char* const xtitle,
		const char* const ytitle, const int xmin, const int xmax,
		const int xscale, const int ymin, const int ymax, const int yscale) {
	int i, xpixoffset = 0, ypixoffset = 0;
	char text[4];

	if (xmin >= xmax || ymin >= ymax) {
		printf("error: incorrect input\n");
		return -1;
	}
	par.xmin = xmin;
	par.xmax = xmax;
	par.ymin = ymin;
	par.ymax = ymax;
	par.xabs = (xmin * xmax < 0) ? abs(xmin) + abs(xmax) : abs(xmax - xmin);
	par.yabs = (ymin * ymax < 0) ? abs(ymin) + abs(ymax) : abs(ymax - ymin);
	par.xpixstep = WIDTH / par.xabs;
	par.ypixstep = HEIGHT / par.yabs;
	par.xpixzero = -xmin * par.xpixstep;
	par.ypixzero = HEIGHT + ymin * par.ypixstep;

	//axis
	if (par.xpixzero < 20)
		xpixoffset = (par.xpixzero < 0) ? -par.xpixzero + 20 : 20;
	if (par.xpixzero > WIDTH - 40)
		xpixoffset = -par.xpixzero + WIDTH - 40;
	if (par.ypixzero < 20)
		ypixoffset = (par.ypixzero <= 0) ? par.ypixzero - 20 : -20;
	if (par.ypixzero > HEIGHT - 20)
		ypixoffset =
				(par.ypixzero >= HEIGHT) ?
						par.ypixzero - HEIGHT + 20 : HEIGHT - 20;
	hlineRGBA(*screen, 0, WIDTH, par.ypixzero - ypixoffset, 255, 255, 255, 255);
	vlineRGBA(*screen, par.xpixzero + xpixoffset, 0, HEIGHT, 255, 255, 255,
			255);

	for (int h = xmin; h <= xmax; h += xscale) {
		vlineRGBA(*screen, par.xpixzero + h * par.xpixstep, 0, HEIGHT, 255, 255,
				255, 100);
		for (int hh =1; hh<=5; hh += 1){
			double s;
			s = h+(h*hh/5);

		vlineRGBA(*screen, par.xpixzero + s  * par.xpixstep, 0, HEIGHT, 255, 255,
						255, 100);
		}

	}

	for (int h = ymin; h <= ymax; h += yscale) {
		hlineRGBA(*screen, 0, WIDTH, par.ypixzero - h * par.ypixstep, 255, 255,
				255, 100);
	}

	//x-scale
	for (i = xmin; i <= xmax; i = i + xscale) {
		sprintf(text, "%d", i);
		lineRGBA(*screen, par.xpixzero + i * par.xpixstep,
				par.ypixzero - ypixoffset, par.xpixzero + i * par.xpixstep,
				par.ypixzero - ypixoffset + 5, 255, 255, 255, 255);
		stringRGBA(*screen, par.xpixzero + i * par.xpixstep,
				par.ypixzero - ypixoffset + 10, text, 255, 255, 255, 255);
	}

	//y-scale
	for (i = ymin; i <= ymax; i = i + yscale) {
		sprintf(text, "%d", i);
		lineRGBA(*screen, par.xpixzero + xpixoffset,
				par.ypixzero - i * par.ypixstep, par.xpixzero + xpixoffset + 5,
				par.ypixzero - i * par.ypixstep, 255, 255, 255, 255);
		stringRGBA(*screen, par.xpixzero + xpixoffset + 10,
				par.ypixzero - i * par.ypixstep, text, 255, 255, 255, 255);
	}

	//titles
	if (par.xpixzero > WIDTH / 2)
		stringRGBA(*screen, par.xpixzero - strlen(ytitle) * 9 + xpixoffset, 5,
				ytitle, 255, 255, 255, 255);
	else
		stringRGBA(*screen, par.xpixzero + 30 + xpixoffset, 5, ytitle, 255, 255,
				255, 255);
	if (par.xpixzero > WIDTH / 2)
		stringRGBA(*screen, 5, par.ypixzero - ypixoffset + 20, xtitle, 255, 255,
				255, 255);
	else
		stringRGBA(*screen, WIDTH - strlen(xtitle) * 9,
				par.ypixzero - ypixoffset - 10, xtitle, 255, 255, 255, 255);
	return 0;
}

/* function DrawDiagram
 * @brief start or continue drawing a line
 * 
 * @param	*screen			pointer to surface handler
 * @param	ln				line number (0 - 9)
 * @param	x				x-coord of the next line ending
 * @param	y				y-coord of the next line ending
 * @param	rr, gg, bb		color values
 * @return	void 
 * 
 * @TODO	maybe a linked list instead of an array
 */
void DrawLine(SDL_Surface **screen, int ln, double x, double y, Uint8 rr,
		Uint8 gg, Uint8 bb) {
	lineRGBA(*screen,
			(Sint16) floor(par.xpixzero + p[0][ln % 10] * par.xpixstep),
			(Sint16) (par.ypixzero - p[1][ln % 10] * par.ypixstep),
			(Sint16) (par.xpixzero + x * par.xpixstep),
			(Sint16) (par.ypixzero - y * par.ypixstep), rr, gg, bb, 255);
	p[0][ln] = x;
	p[1][ln] = y;
}

/* function DrawDiagram
 * @brief start or continue drawing a line
 * 
 * @param	*screen			pointer to surface handler
 * @param	ln				line number (0 - 9)
 * @param	x				x-coord of the next line ending
 * @param	y				y-coord of the next line ending
 * @param	c				color value
 * @return	void 
 * 
 * @TODO	maybe a linked list instead of an array
 */
void DrawLine(SDL_Surface **screen, const int ln, const double x,
		const double y, const color &c) {
	DrawLine(screen, ln, x, y, c.red, c.green, c.blue);
}
